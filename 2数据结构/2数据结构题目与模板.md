# AcWing 算法基础课 -- 数据结构
[TOC]
包括单链表，双链表，栈，队列，单调栈，单调队列，KMP，Trie，并查集，堆，哈希表等内容。

## 题目


- [x] AcWing 826. 单链表
- [x] AcWing 827. 双链表
- [ ] AcWing 828. 模拟栈
- [ ] AcWing 829. 模拟队列
- [ ] AcWing 830. 单调栈
- [ ] AcWing 154. 滑动窗口
- [ ] AcWing 831. KMP字符串
- [ ] AcWing 835. Trie字符串统计
- [ ] AcWing 143. 最大异或对
- [ ] AcWing 836. 合并集合
- [ ] AcWing 837. 连通块中点的数量
- [ ] AcWing 240. 食物链
- [ ] AcWing 838. 堆排序
- [ ] AcWing 839. 模拟堆
- [ ] AcWing 840. 模拟散列表
- [ ] AcWing 841. 字符串哈希


## 模板

参考 AcWing [https://www.acwing.com/blog/content/404/](https://www.acwing.com/blog/content/404/)

### 单链表 —— 模板题 AcWing 826. 单链表

1. AcWing数组模拟单链表

```cpp
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```
2. 模板题 Java 题解

```java
import java.util.*;
import java.io.*;

public class Main{
    public static int N = 100010;
    public static int[] e = new int[N];
    public static int[] ne = new int[N];
    public static int head = 0;
    public static int idx = 1;
    public static void main(String[] args) throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int m = Integer.parseInt(in.readLine());
        while(m > 0){
            m--;
            String[] s = in.readLine().split(" ");
            if(s[0].equals("H")){
                int x = Integer.parseInt(s[1]);
                addHead(x);
            }else if(s[0].equals("D")){
                int k = Integer.parseInt(s[1]);
                remove(k);
            }else{
                int k = Integer.parseInt(s[1]);
                int x = Integer.parseInt(s[2]);
                add(k, x);
            }
        }
        for(int i = head; i != 0; i = ne[i]) System.out.print(e[i] + " ");
        
    }
    public static void addHead(int x){
        // 先记录 idx 的值
        // 然后让 idx 指向头结点指向的结点
        // 修改头结点的指向为 idx
        // idx 加 1
        e[idx] = x;
        ne[idx] = head;
        head = idx;
        idx++;
    }
    public static void remove(int k){
        // 如果 k 为 0，删除头结点
        if(k == 0)  head = ne[head];
        // 第 k 个结点指向 next 的 next
        else    ne[k] = ne[ne[k]];
    }
    public static void add(int k, int x){
        // 先记录 idx 的值
        // 然后让 idx 指向第 k 指向的结点
        // 修改第 k 个结点的指向为 idx
        // idx 加 1
        e[idx] = x;
        ne[idx] = ne[k];
        ne[k] = idx;
        idx++;
    }
}
```

### 双链表 —— 模板题 AcWing 827. 双链表

1. AcWing数组模拟双链表模板

```cpp
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

2. 模板题 Java 解答

```java
import java.util.*;
import java.io.*;

public class Main{
    public static final int N = 100010;
    public static int[] e = new int[N];
    public static int[] l = new int[N];
    public static int[] r = new int[N];
    public static int idx;
    // 规定双向链表的头的位置（最左侧）为0，尾的位置（最右侧）为 100005
    // 插入的第 1 个结点只能从 1 开始
    public static void main(String[] args) throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int m = Integer.parseInt(in.readLine());
        init();
        int x, k;
        while(m > 0){
            m--;
            String[] s = in.readLine().split(" ");  
            switch(s[0]){
                case "L" :
                    // 在链表最左端插入数 x
                    // 也就是在头结点的右边插入数 x
                    x = Integer.parseInt(s[1]);
                    add(0, x);
                    break;
                case "R" :
                    // 在链表的最右端插入数 x
                    // 也就是在尾结点的左边插入数 x
                    x = Integer.parseInt(s[1]);
                    add(l[100005], x);
                    break;
                case "D" :
                    // 将第 k 个插入的数删除
                    k = Integer.parseInt(s[1]);
                    remove(k);
                    break;
                case "IL" :
                    // 在第 k 个插入的数左侧插入一个数字
                    k = Integer.parseInt(s[1]);
                    x = Integer.parseInt(s[2]);
                    add(l[k], x);
                    break;
                case "IR" :
                    // 在第 k 个插入的数右侧插入一个数字
                    k = Integer.parseInt(s[1]);
                    x = Integer.parseInt(s[2]);
                    add(k, x);
                    break;
            }
        }
        for(int i = r[0]; i != 100005; i = r[i]){
            System.out.print(e[i] + " ");
        }
    }
    public static void init(){
        r[0] = 100005;
        l[100005] = 0;
        idx = 1;
    }
    public static void add(int k, int x){
        e[idx] = x;
        r[idx] = r[k];
        l[idx] = k;
        l[r[k]] = idx;
        r[k] = idx;
        idx++;
        
    }
    public static void remove(int k){
        r[l[k]] = r[k];
        l[r[k]] = l[k];
    }
}
```
### 栈 —— 模板题 AcWing 828. 模拟栈

1. 数组模拟栈

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```

2. 模板题 Java 题解

```java
import java.util.*;
import java.io.*;

public class Main{
    public static final int N = 100010;
    public static int[] stk = new int[N];
    public static int tt = 0;
    public static void main(String[] args) throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int m = Integer.parseInt(in.readLine());
        while(m > 0){
            m--;
            String[] s = in.readLine().split(" ");
            if(s[0].equals("push")){
                int x = Integer.parseInt(s[1]);
                stk[tt] = x;
                tt++;
            }else if(s[0].equals("pop")){
                tt--;
            }else if(s[0].equals("empty")){
                String res = tt == 0 ? "YES" : "NO";
                System.out.println(res);
            }else if(s[0].equals("query")){
                System.out.println(stk[tt - 1]);
            }
        }
    }
}
```
### 队列 —— 模板题 AcWing 829. 模拟队列

1. 数组模拟普通队列

```cpp
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}
```

2. 数组模拟循环队列

```cpp
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```

3. 模板题 Java 题解

```java
import java.util.*;
import java.io.*;

public class Main{
    public static final int N = 100010;
    public static int[] q = new int[N];
    public static int idx = 0;
    // hh 表示队头
    // tt 表示队尾
    // 队列队尾插入数据,队首弹出数据
    // hh 和 tt 的初始化要注意是 0 还是 -1,不同的初始化在 push 操作是不一样的,自己画图推导一下
    public static int hh = 0, tt = 0;
    public static void main(String[] args) throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int m = Integer.parseInt(in.readLine());
        while(m > 0){
            m--;
            String[] s = in.readLine().split(" ");
            if(s[0].equals("push")){
                q[tt] = Integer.parseInt(s[1]);
                tt++;
            }else if(s[0].equals("pop")){
                hh++;
            }else if(s[0].equals("empty")){
                String res = hh < tt ? "NO" : "YES";
                System.out.println(res);
            }else if(s[0].equals("query")){
                System.out.println(q[hh]);
            }
        }
    }
}
```

### 单调栈 —— 模板题 AcWing 830. 单调栈

**单调栈常用题型**：各一个序列，在序列中每一个数的左边离他最近的最大的数字在什么地方，这个左边右边、最大最小是一个意思。

1. 单调栈模板

```cpp
// 常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

2. 模板题 Java 解答

```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws IOException{
        int N = 100010;
        int[] stk = new int[N];
        int tt = 0;
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(in.readLine());
        String[] s = in.readLine().split(" ");
        for(int i = 0; i < n; i++){
            int x = Integer.parseInt(s[i]);
            while(tt > 0 && stk[tt] >= x) tt--;
            if(tt > 0) System.out.print(stk[tt] + " ");
            else System.out.print(-1 + " ");
            tt++;
            stk[tt] = x;
        }
    }
}
```
### 单调队列 —— 模板题 AcWing 154. 滑动窗口

```cpp
// 常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```
### KMP —— 模板题 AcWing 831. KMP字符串
### Trie树 —— 模板题 AcWing 835. Trie字符串统计
### 并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量
并查集快速处理这样的问题
1. 将两个集合合并
2. 询问两个元素是否在一个集合当中

近乎$O(1)$的时间复杂度快速实现这两个操作。

---

基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。
1. 问题一：如何判断树根：if(p[x] == x)，除了根节点之外，p[x]都不等于x。
2. 问题二：如何求x的集合编号:while(p[x] != x) x = p[x]
3. 问题三：如何合并两个集合：p[x]是x的集合编号，p[y]是y的集合编号，p[x] = y。
4. 优化：
   1. 路径压缩：一个节点找到根节点，就把路径上经过的节点都指向根节点。
   2. 按质合并：一般很少用
模板代码
```java
// 返回x的祖宗节点，并且用了路径压缩
int find(int x){
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
} 
```
### 堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆
### 一般哈希 —— 模板题 AcWing 840. 模拟散列表
### 字符串哈希 —— 模板题 AcWing 841. 字符串哈希
### C++ STL简介//写一份java的