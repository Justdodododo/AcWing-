# AcWing 算法基础课 -- 数据结构
[TOC]
包括单链表，双链表，栈，队列，单调栈，单调队列，KMP，Trie，并查集，堆，哈希表等内容。

## 题目


- [ ] AcWing 826. 单链表
- [ ] AcWing 827. 双链表
- [ ] AcWing 828. 模拟栈
- [ ] AcWing 829. 模拟队列
- [ ] AcWing 830. 单调栈
- [ ] AcWing 154. 滑动窗口
- [ ] AcWing 831. KMP字符串
- [ ] AcWing 835. Trie字符串统计
- [ ] AcWing 143. 最大异或对
- [ ] AcWing 836. 合并集合
- [ ] AcWing 837. 连通块中点的数量
- [ ] AcWing 240. 食物链
- [ ] AcWing 838. 堆排序
- [ ] AcWing 839. 模拟堆
- [ ] AcWing 840. 模拟散列表
- [ ] AcWing 841. 字符串哈希


## 模板

参考 AcWing [https://www.acwing.com/blog/content/404/](https://www.acwing.com/blog/content/404/)

### 单链表 —— 模板题 AcWing 826. 单链表

数组模拟单链表

```cpp
// head 表示头节点下标
// e[i] 节点 i 的值
// ne[i] 节点 i 的下一个节点的 下标
// 空节点的下标为 -1
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```
### 双链表 —— 模板题 AcWing 827. 双链表

数组模拟双链表

```cpp
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
### 栈 —— 模板题 AcWing 828. 模拟栈

数组模拟栈

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```
### 队列 —— 模板题 AcWing 829. 模拟队列

1. 数组模拟普通队列

```cpp
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}
```

2. 数组模拟循环队列

```cpp
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```
### 单调栈 —— 模板题 AcWing 830. 单调栈

```cpp
// 常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
### 单调队列 —— 模板题 AcWing 154. 滑动窗口

```cpp
// 常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```
### KMP —— 模板题 AcWing 831. KMP字符串
### Trie树 —— 模板题 AcWing 835. Trie字符串统计
### 并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量
并查集快速处理这样的问题
1. 将两个集合合并
2. 询问两个元素是否在一个集合当中

近乎$O(1)$的时间复杂度快速实现这两个操作。

---

基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。
1. 问题一：如何判断树根：if(p[x] == x)，除了根节点之外，p[x]都不等于x。
2. 问题二：如何求x的集合编号:while(p[x] != x) x = p[x]
3. 问题三：如何合并两个集合：p[x]是x的集合编号，p[y]是y的集合编号，p[x] = y。
4. 优化：
   1. 路径压缩：一个节点找到根节点，就把路径上经过的节点都指向根节点。
   2. 按质合并：一般很少用
模板代码
```java
// 返回x的祖宗节点，并且用了路径压缩
int find(int x){
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
} 
```
### 堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆
### 一般哈希 —— 模板题 AcWing 840. 模拟散列表
### 字符串哈希 —— 模板题 AcWing 841. 字符串哈希
### C++ STL简介//写一份java的