# AcWing 算法基础课 -- 数学知识

[TOC]

包括DFS，BFS，树与图的深度优先遍历，树与图的广度优先遍历，拓扑排序，Dijkstra，bellman-ford，spfa，Floyd，Prim，Kruskal，染色法判定二分图，匈牙利算法等内容。

## 题目

DFS
- [ ] AcWing 842. 排列数字
- [ ] AcWing 843. n-皇后问题

BFS
- [ ] AcWing 844. 走迷宫
- [ ] AcWing 845. 八数码

树与图的深度优先遍历
- [ ] AcWing 846. 树的重心

树与图的广度优先遍历
- [ ] AcWing 847. 图中点的层次

拓扑排序
- [ ] AcWing 848. 有向图的拓扑序列

Dijkstra
- [ ] AcWing 849. Dijkstra求最短路 I
- [ ] AcWing 850. Dijkstra求最短路 II

bellman-ford
- [ ] AcWing 853. 有边数限制的最短路

spfa
- [ ] AcWing 851. spfa求最短路
- [ ] AcWing 852. spfa判断负环

Floyd
- [ ] AcWing 854. Floyd求最短路

Prim
- [ ] AcWing 858. Prim算法求最小生成树

Kruskal
- [ ] AcWing 859. Kruskal算法求最小生成树

染色法判定二分图
- [ ] AcWing 860. 染色法判定二分图

匈牙利算法
- [ ] AcWing 861. 二分图的最大匹配

## 模板

参考 AcWing [https://www.acwing.com/blog/content/405/](https://www.acwing.com/blog/content/405/)

||数据结构|空间|性质|
|---|---|---|---|
|DFS|stack|O(h)|不具有最短性|
|BFS|queue|O(2^n)|最短路|

### 树与图的存储

树是一种特殊的图，与图的存储方式相同。图分有向图和无向图，对于无向图中的边ab，存储两条有向边a->b, b->a。所以只需要考虑有向图就可以了。

有向图的存储：邻接矩阵`g[a][b] 存储边a->b`或者邻接表

```cpp
// 邻接表存储图
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

### 树与图的遍历

时间复杂度 O(n+m), n 表示点数，m 表示边数

1. 深度优先遍历 —— 模板题 AcWing 846. 树的重心
```cpp
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```
2. 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次
```cpp
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

### 拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列

时间复杂度 O(n+m), n 表示点数，m 表示边数

**有向图才会有拓扑序列**，若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。

```cpp
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```